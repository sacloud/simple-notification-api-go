// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *CommonServiceItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItem) encodeFields(e *jx.Encoder) {
	{
		if s.Index.Set {
			e.FieldStart("Index")
			s.Index.Encode(e)
		}
	}
	{
		e.FieldStart("ID")
		e.Str(s.ID)
	}
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("Description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("Settings")
		s.Settings.Encode(e)
	}
	{
		e.FieldStart("CreatedAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("ModifiedAt")
		json.EncodeDateTime(e, s.ModifiedAt)
	}
	{
		e.FieldStart("Provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("Icon")
		s.Icon.Encode(e)
	}
	{
		e.FieldStart("Tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCommonServiceItem = [10]string{
	0: "Index",
	1: "ID",
	2: "Name",
	3: "Description",
	4: "Settings",
	5: "CreatedAt",
	6: "ModifiedAt",
	7: "Provider",
	8: "Icon",
	9: "Tags",
}

// Decode decodes CommonServiceItem from json.
func (s *CommonServiceItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Index":
			if err := func() error {
				s.Index.Reset()
				if err := s.Index.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Index\"")
			}
		case "ID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ID\"")
			}
		case "Name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Settings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		case "CreatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CreatedAt\"")
			}
		case "ModifiedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ModifiedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ModifiedAt\"")
			}
		case "Provider":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Provider\"")
			}
		case "Icon":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Icon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Icon\"")
			}
		case "Tags":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111110,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonServiceItem) {
					name = jsonFieldsNameOfCommonServiceItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommonServiceItemDestinationSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItemDestinationSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("Value")
		e.Str(s.Value)
	}
	{
		if s.Disabled.Set {
			e.FieldStart("Disabled")
			s.Disabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommonServiceItemDestinationSettings = [3]string{
	0: "Type",
	1: "Value",
	2: "Disabled",
}

// Decode decodes CommonServiceItemDestinationSettings from json.
func (s *CommonServiceItemDestinationSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemDestinationSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Type\"")
			}
		case "Value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Value\"")
			}
		case "Disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Disabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItemDestinationSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonServiceItemDestinationSettings) {
					name = jsonFieldsNameOfCommonServiceItemDestinationSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItemDestinationSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemDestinationSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommonServiceItemDestinationSettingsType as json.
func (s CommonServiceItemDestinationSettingsType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CommonServiceItemDestinationSettingsType from json.
func (s *CommonServiceItemDestinationSettingsType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemDestinationSettingsType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CommonServiceItemDestinationSettingsType(v) {
	case CommonServiceItemDestinationSettingsTypeEmail:
		*s = CommonServiceItemDestinationSettingsTypeEmail
	case CommonServiceItemDestinationSettingsTypeWebhook:
		*s = CommonServiceItemDestinationSettingsTypeWebhook
	default:
		*s = CommonServiceItemDestinationSettingsType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommonServiceItemDestinationSettingsType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemDestinationSettingsType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommonServiceItemGroupSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItemGroupSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Destinations")
		e.ArrStart()
		for _, elem := range s.Destinations {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Disabled.Set {
			e.FieldStart("Disabled")
			s.Disabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfCommonServiceItemGroupSettings = [2]string{
	0: "Destinations",
	1: "Disabled",
}

// Decode decodes CommonServiceItemGroupSettings from json.
func (s *CommonServiceItemGroupSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemGroupSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Destinations":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Destinations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Destinations = append(s.Destinations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Destinations\"")
			}
		case "Disabled":
			if err := func() error {
				s.Disabled.Reset()
				if err := s.Disabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Disabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItemGroupSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonServiceItemGroupSettings) {
					name = jsonFieldsNameOfCommonServiceItemGroupSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItemGroupSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemGroupSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommonServiceItemIcon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItemIcon) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCommonServiceItemIcon = [0]string{}

// Decode decodes CommonServiceItemIcon from json.
func (s *CommonServiceItemIcon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemIcon to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItemIcon")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItemIcon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemIcon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommonServiceItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Class")
		s.Class.Encode(e)
	}
}

var jsonFieldsNameOfCommonServiceItemProvider = [1]string{
	0: "Class",
}

// Decode decodes CommonServiceItemProvider from json.
func (s *CommonServiceItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonServiceItemProvider) {
					name = jsonFieldsNameOfCommonServiceItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommonServiceItemProviderClass as json.
func (s CommonServiceItemProviderClass) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CommonServiceItemProviderClass from json.
func (s *CommonServiceItemProviderClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemProviderClass to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CommonServiceItemProviderClass(v) {
	case CommonServiceItemProviderClassSaknoticedestination:
		*s = CommonServiceItemProviderClassSaknoticedestination
	case CommonServiceItemProviderClassSaknoticegroup:
		*s = CommonServiceItemProviderClassSaknoticegroup
	case CommonServiceItemProviderClassSaknoticerouting:
		*s = CommonServiceItemProviderClassSaknoticerouting
	default:
		*s = CommonServiceItemProviderClass(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommonServiceItemProviderClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemProviderClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommonServiceItemRoutingSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItemRoutingSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("MatchLabels")
		e.ArrStart()
		for _, elem := range s.MatchLabels {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("SourceID")
		e.Str(s.SourceID)
	}
	{
		e.FieldStart("TargetGroupID")
		e.Str(s.TargetGroupID)
	}
	{
		e.FieldStart("PriorityRank")
		e.Int(s.PriorityRank)
	}
}

var jsonFieldsNameOfCommonServiceItemRoutingSettings = [4]string{
	0: "MatchLabels",
	1: "SourceID",
	2: "TargetGroupID",
	3: "PriorityRank",
}

// Decode decodes CommonServiceItemRoutingSettings from json.
func (s *CommonServiceItemRoutingSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemRoutingSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "MatchLabels":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.MatchLabels = make([]CommonServiceItemRoutingSettingsMatchLabelsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommonServiceItemRoutingSettingsMatchLabelsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.MatchLabels = append(s.MatchLabels, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"MatchLabels\"")
			}
		case "SourceID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SourceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SourceID\"")
			}
		case "TargetGroupID":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TargetGroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"TargetGroupID\"")
			}
		case "PriorityRank":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.PriorityRank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PriorityRank\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItemRoutingSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonServiceItemRoutingSettings) {
					name = jsonFieldsNameOfCommonServiceItemRoutingSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItemRoutingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemRoutingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CommonServiceItemRoutingSettingsMatchLabelsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CommonServiceItemRoutingSettingsMatchLabelsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("Value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfCommonServiceItemRoutingSettingsMatchLabelsItem = [2]string{
	0: "Name",
	1: "Value",
}

// Decode decodes CommonServiceItemRoutingSettingsMatchLabelsItem from json.
func (s *CommonServiceItemRoutingSettingsMatchLabelsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemRoutingSettingsMatchLabelsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CommonServiceItemRoutingSettingsMatchLabelsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCommonServiceItemRoutingSettingsMatchLabelsItem) {
					name = jsonFieldsNameOfCommonServiceItemRoutingSettingsMatchLabelsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CommonServiceItemRoutingSettingsMatchLabelsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemRoutingSettingsMatchLabelsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CommonServiceItemSettings as json.
func (s CommonServiceItemSettings) Encode(e *jx.Encoder) {
	switch s.Type {
	case CommonServiceItemDestinationSettingsCommonServiceItemSettings:
		s.CommonServiceItemDestinationSettings.Encode(e)
	case CommonServiceItemGroupSettingsCommonServiceItemSettings:
		s.CommonServiceItemGroupSettings.Encode(e)
	case CommonServiceItemRoutingSettingsCommonServiceItemSettings:
		s.CommonServiceItemRoutingSettings.Encode(e)
	}
}

func (s CommonServiceItemSettings) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CommonServiceItemDestinationSettingsCommonServiceItemSettings:
		s.CommonServiceItemDestinationSettings.encodeFields(e)
	case CommonServiceItemGroupSettingsCommonServiceItemSettings:
		s.CommonServiceItemGroupSettings.encodeFields(e)
	case CommonServiceItemRoutingSettingsCommonServiceItemSettings:
		s.CommonServiceItemRoutingSettings.encodeFields(e)
	}
}

// Decode decodes CommonServiceItemSettings from json.
func (s *CommonServiceItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CommonServiceItemSettings to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "Destinations":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemGroupSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "MatchLabels":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "PriorityRank":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Number {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "SourceID":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "TargetGroupID":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "Type":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemDestinationSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "Value":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemDestinationSettingsCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CommonServiceItemDestinationSettingsCommonServiceItemSettings:
		if err := s.CommonServiceItemDestinationSettings.Decode(d); err != nil {
			return err
		}
	case CommonServiceItemGroupSettingsCommonServiceItemSettings:
		if err := s.CommonServiceItemGroupSettings.Decode(d); err != nil {
			return err
		}
	case CommonServiceItemRoutingSettingsCommonServiceItemSettings:
		if err := s.CommonServiceItemRoutingSettings.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CommonServiceItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CommonServiceItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateCommonServiceItemOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateCommonServiceItemOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("CommonServiceItem")
		s.CommonServiceItem.Encode(e)
	}
}

var jsonFieldsNameOfCreateCommonServiceItemOK = [1]string{
	0: "CommonServiceItem",
}

// Decode decodes CreateCommonServiceItemOK from json.
func (s *CreateCommonServiceItemOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateCommonServiceItemOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CommonServiceItem":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommonServiceItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateCommonServiceItemOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateCommonServiceItemOK) {
					name = jsonFieldsNameOfCreateCommonServiceItemOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateCommonServiceItemOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateCommonServiceItemOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteCommonServiceItemOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteCommonServiceItemOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("CommonServiceItem")
		s.CommonServiceItem.Encode(e)
	}
}

var jsonFieldsNameOfDeleteCommonServiceItemOK = [1]string{
	0: "CommonServiceItem",
}

// Decode decodes DeleteCommonServiceItemOK from json.
func (s *DeleteCommonServiceItemOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCommonServiceItemOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CommonServiceItem":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommonServiceItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteCommonServiceItemOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteCommonServiceItemOK) {
					name = jsonFieldsNameOfDeleteCommonServiceItemOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCommonServiceItemOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCommonServiceItemOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Error) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Error) encodeFields(e *jx.Encoder) {
	{
		if s.IsFatal.Set {
			e.FieldStart("is_fatal")
			s.IsFatal.Encode(e)
		}
	}
	{
		if s.Serial.Set {
			e.FieldStart("serial")
			s.Serial.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("error_code")
			s.ErrorCode.Encode(e)
		}
	}
	{
		if s.ErrorMsg.Set {
			e.FieldStart("error_msg")
			s.ErrorMsg.Encode(e)
		}
	}
}

var jsonFieldsNameOfError = [5]string{
	0: "is_fatal",
	1: "serial",
	2: "status",
	3: "error_code",
	4: "error_msg",
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_fatal":
			if err := func() error {
				s.IsFatal.Reset()
				if err := s.IsFatal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_fatal\"")
			}
		case "serial":
			if err := func() error {
				s.Serial.Reset()
				if err := s.Serial.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serial\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_code":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_code\"")
			}
		case "error_msg":
			if err := func() error {
				s.ErrorMsg.Reset()
				if err := s.ErrorMsg.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_msg\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Error")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCommonServiceItemOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCommonServiceItemOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("CommonServiceItem")
		s.CommonServiceItem.Encode(e)
	}
}

var jsonFieldsNameOfGetCommonServiceItemOK = [1]string{
	0: "CommonServiceItem",
}

// Decode decodes GetCommonServiceItemOK from json.
func (s *GetCommonServiceItemOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommonServiceItemOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CommonServiceItem":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommonServiceItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCommonServiceItemOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCommonServiceItemOK) {
					name = jsonFieldsNameOfGetCommonServiceItemOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommonServiceItemOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommonServiceItemOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCommonServiceItemStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCommonServiceItemStatusResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("NotificationStatus")
		s.NotificationStatus.Encode(e)
	}
}

var jsonFieldsNameOfGetCommonServiceItemStatusResponse = [1]string{
	0: "NotificationStatus",
}

// Decode decodes GetCommonServiceItemStatusResponse from json.
func (s *GetCommonServiceItemStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommonServiceItemStatusResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "NotificationStatus":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NotificationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NotificationStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCommonServiceItemStatusResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCommonServiceItemStatusResponse) {
					name = jsonFieldsNameOfGetCommonServiceItemStatusResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommonServiceItemStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommonServiceItemStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCommonServiceItemStatusResponseNotificationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCommonServiceItemStatusResponseNotificationStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("IsValid")
		e.Bool(s.IsValid)
	}
	{
		e.FieldStart("ModifiedAt")
		json.EncodeDateTime(e, s.ModifiedAt)
	}
}

var jsonFieldsNameOfGetCommonServiceItemStatusResponseNotificationStatus = [2]string{
	0: "IsValid",
	1: "ModifiedAt",
}

// Decode decodes GetCommonServiceItemStatusResponseNotificationStatus from json.
func (s *GetCommonServiceItemStatusResponseNotificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCommonServiceItemStatusResponseNotificationStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IsValid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsValid = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsValid\"")
			}
		case "ModifiedAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ModifiedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ModifiedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCommonServiceItemStatusResponseNotificationStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCommonServiceItemStatusResponseNotificationStatus) {
					name = jsonFieldsNameOfGetCommonServiceItemStatusResponseNotificationStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCommonServiceItemStatusResponseNotificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCommonServiceItemStatusResponseNotificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSimpleNotificationHistoryResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSimpleNotificationHistoryResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("NotificationHistory")
		s.NotificationHistory.Encode(e)
	}
}

var jsonFieldsNameOfGetSimpleNotificationHistoryResponse = [1]string{
	0: "NotificationHistory",
}

// Decode decodes GetSimpleNotificationHistoryResponse from json.
func (s *GetSimpleNotificationHistoryResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSimpleNotificationHistoryResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "NotificationHistory":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.NotificationHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NotificationHistory\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSimpleNotificationHistoryResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSimpleNotificationHistoryResponse) {
					name = jsonFieldsNameOfGetSimpleNotificationHistoryResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSimpleNotificationHistoryResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSimpleNotificationHistoryResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListCommonServiceItemsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListCommonServiceItemsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("From")
			s.From.Encode(e)
		}
	}
	{
		if s.Count.Set {
			e.FieldStart("Count")
			s.Count.Encode(e)
		}
	}
	{
		if s.Total.Set {
			e.FieldStart("Total")
			s.Total.Encode(e)
		}
	}
	{
		e.FieldStart("CommonServiceItems")
		e.ArrStart()
		for _, elem := range s.CommonServiceItems {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListCommonServiceItemsResponse = [4]string{
	0: "From",
	1: "Count",
	2: "Total",
	3: "CommonServiceItems",
}

// Decode decodes ListCommonServiceItemsResponse from json.
func (s *ListCommonServiceItemsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListCommonServiceItemsResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "From":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"From\"")
			}
		case "Count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Count\"")
			}
		case "Total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Total\"")
			}
		case "CommonServiceItems":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.CommonServiceItems = make([]CommonServiceItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CommonServiceItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.CommonServiceItems = append(s.CommonServiceItems, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItems\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListCommonServiceItemsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListCommonServiceItemsResponse) {
					name = jsonFieldsNameOfListCommonServiceItemsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListCommonServiceItemsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListCommonServiceItemsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ListSimpleNotificationHistoriesResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ListSimpleNotificationHistoriesResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("NotificationHistories")
		e.ArrStart()
		for _, elem := range s.NotificationHistories {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfListSimpleNotificationHistoriesResponse = [1]string{
	0: "NotificationHistories",
}

// Decode decodes ListSimpleNotificationHistoriesResponse from json.
func (s *ListSimpleNotificationHistoriesResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListSimpleNotificationHistoriesResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "NotificationHistories":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.NotificationHistories = make([]NotificationHistory, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NotificationHistory
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NotificationHistories = append(s.NotificationHistories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NotificationHistories\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ListSimpleNotificationHistoriesResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfListSimpleNotificationHistoriesResponse) {
					name = jsonFieldsNameOfListSimpleNotificationHistoriesResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ListSimpleNotificationHistoriesResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListSimpleNotificationHistoriesResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("request_id")
		e.Str(s.RequestID)
	}
	{
		e.FieldStart("source_id")
		e.Str(s.SourceID)
	}
	{
		e.FieldStart("statuses")
		e.ArrStart()
		for _, elem := range s.Statuses {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("received_at")
		json.EncodeDateTime(e, s.ReceivedAt)
	}
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
}

var jsonFieldsNameOfNotificationHistory = [5]string{
	0: "request_id",
	1: "source_id",
	2: "statuses",
	3: "received_at",
	4: "message",
}

// Decode decodes NotificationHistory from json.
func (s *NotificationHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "request_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.RequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request_id\"")
			}
		case "source_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SourceID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_id\"")
			}
		case "statuses":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Statuses = make([]NotificationStatus, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NotificationStatus
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Statuses = append(s.Statuses, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statuses\"")
			}
		case "received_at":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ReceivedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"received_at\"")
			}
		case "message":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationHistory) {
					name = jsonFieldsNameOfNotificationHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("color")
		e.Str(s.Color)
	}
	{
		e.FieldStart("color_code")
		e.Str(s.ColorCode)
	}
	{
		e.FieldStart("icon_url")
		e.Str(s.IconURL)
	}
	{
		e.FieldStart("image_url")
		e.Str(s.ImageURL)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfNotificationMessage = [6]string{
	0: "body",
	1: "color",
	2: "color_code",
	3: "icon_url",
	4: "image_url",
	5: "title",
}

// Decode decodes NotificationMessage from json.
func (s *NotificationMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "color":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Color = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "color_code":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ColorCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color_code\"")
			}
		case "icon_url":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.IconURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "image_url":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ImageURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_url\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationMessage) {
					name = jsonFieldsNameOfNotificationMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationStatus) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		e.FieldStart("error_info")
		e.Str(s.ErrorInfo)
	}
	{
		e.FieldStart("notification_request_id")
		e.Str(s.NotificationRequestID)
	}
	{
		e.FieldStart("group_id")
		e.Str(s.GroupID)
	}
	{
		e.FieldStart("destination_id")
		e.Str(s.DestinationID)
	}
	{
		e.FieldStart("created_at")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updated_at")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfNotificationStatus = [8]string{
	0: "id",
	1: "status",
	2: "error_info",
	3: "notification_request_id",
	4: "group_id",
	5: "destination_id",
	6: "created_at",
	7: "updated_at",
}

// Decode decodes NotificationStatus from json.
func (s *NotificationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationStatus to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "error_info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ErrorInfo = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error_info\"")
			}
		case "notification_request_id":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.NotificationRequestID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notification_request_id\"")
			}
		case "group_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.GroupID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group_id\"")
			}
		case "destination_id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DestinationID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"destination_id\"")
			}
		case "created_at":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created_at\"")
			}
		case "updated_at":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated_at\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationStatus")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotificationStatus) {
					name = jsonFieldsNameOfNotificationStatus[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationStatusStatus as json.
func (s NotificationStatusStatus) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes NotificationStatusStatus from json.
func (s *NotificationStatusStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationStatusStatus to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = NotificationStatusStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationStatusStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationStatusStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostCommonServiceItemRequest as json.
func (o OptPostCommonServiceItemRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PostCommonServiceItemRequest from json.
func (o *OptPostCommonServiceItemRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPostCommonServiceItemRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPostCommonServiceItemRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPostCommonServiceItemRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutCommonServiceItemRequest as json.
func (o OptPutCommonServiceItemRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PutCommonServiceItemRequest from json.
func (o *OptPutCommonServiceItemRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPutCommonServiceItemRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPutCommonServiceItemRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPutCommonServiceItemRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutCommonServiceItemRequestCommonServiceItemSettings as json.
func (o OptPutCommonServiceItemRequestCommonServiceItemSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PutCommonServiceItemRequestCommonServiceItemSettings from json.
func (o *OptPutCommonServiceItemRequestCommonServiceItemSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPutCommonServiceItemRequestCommonServiceItemSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPutCommonServiceItemRequestCommonServiceItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPutCommonServiceItemRequestCommonServiceItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutCommonServiceItemRoutingReorderRequest as json.
func (o OptPutCommonServiceItemRoutingReorderRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PutCommonServiceItemRoutingReorderRequest from json.
func (o *OptPutCommonServiceItemRoutingReorderRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPutCommonServiceItemRoutingReorderRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPutCommonServiceItemRoutingReorderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPutCommonServiceItemRoutingReorderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SendNotificationMessageRequest as json.
func (o OptSendNotificationMessageRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SendNotificationMessageRequest from json.
func (o *OptSendNotificationMessageRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSendNotificationMessageRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSendNotificationMessageRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSendNotificationMessageRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostCommonServiceItemRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostCommonServiceItemRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("CommonServiceItem")
		s.CommonServiceItem.Encode(e)
	}
}

var jsonFieldsNameOfPostCommonServiceItemRequest = [1]string{
	0: "CommonServiceItem",
}

// Decode decodes PostCommonServiceItemRequest from json.
func (s *PostCommonServiceItemRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostCommonServiceItemRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CommonServiceItem":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommonServiceItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostCommonServiceItemRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostCommonServiceItemRequest) {
					name = jsonFieldsNameOfPostCommonServiceItemRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostCommonServiceItemRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostCommonServiceItemRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostCommonServiceItemRequestCommonServiceItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostCommonServiceItemRequestCommonServiceItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("Description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("Tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Icon")
		s.Icon.Encode(e)
	}
	{
		e.FieldStart("Provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("Settings")
		s.Settings.Encode(e)
	}
}

var jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItem = [6]string{
	0: "Name",
	1: "Description",
	2: "Tags",
	3: "Icon",
	4: "Provider",
	5: "Settings",
}

// Decode decodes PostCommonServiceItemRequestCommonServiceItem from json.
func (s *PostCommonServiceItemRequestCommonServiceItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostCommonServiceItemRequestCommonServiceItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "Icon":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Icon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Icon\"")
			}
		case "Provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Provider\"")
			}
		case "Settings":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostCommonServiceItemRequestCommonServiceItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItem) {
					name = jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostCommonServiceItemRequestCommonServiceItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostCommonServiceItemRequestCommonServiceItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemIcon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostCommonServiceItemRequestCommonServiceItemIcon) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItemIcon = [0]string{}

// Decode decodes PostCommonServiceItemRequestCommonServiceItemIcon from json.
func (s *PostCommonServiceItemRequestCommonServiceItemIcon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostCommonServiceItemRequestCommonServiceItemIcon to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PostCommonServiceItemRequestCommonServiceItemIcon")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemIcon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemIcon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PostCommonServiceItemRequestCommonServiceItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Class")
		s.Class.Encode(e)
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ServiceClass.Set {
			e.FieldStart("ServiceClass")
			s.ServiceClass.Encode(e)
		}
	}
}

var jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItemProvider = [3]string{
	0: "Class",
	1: "Name",
	2: "ServiceClass",
}

// Decode decodes PostCommonServiceItemRequestCommonServiceItemProvider from json.
func (s *PostCommonServiceItemRequestCommonServiceItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostCommonServiceItemRequestCommonServiceItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Class":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Class.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Class\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "ServiceClass":
			if err := func() error {
				s.ServiceClass.Reset()
				if err := s.ServiceClass.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ServiceClass\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PostCommonServiceItemRequestCommonServiceItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItemProvider) {
					name = jsonFieldsNameOfPostCommonServiceItemRequestCommonServiceItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostCommonServiceItemRequestCommonServiceItemProviderClass as json.
func (s PostCommonServiceItemRequestCommonServiceItemProviderClass) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PostCommonServiceItemRequestCommonServiceItemProviderClass from json.
func (s *PostCommonServiceItemRequestCommonServiceItemProviderClass) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostCommonServiceItemRequestCommonServiceItemProviderClass to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PostCommonServiceItemRequestCommonServiceItemProviderClass(v) {
	case PostCommonServiceItemRequestCommonServiceItemProviderClassSaknoticedestination:
		*s = PostCommonServiceItemRequestCommonServiceItemProviderClassSaknoticedestination
	case PostCommonServiceItemRequestCommonServiceItemProviderClassSaknoticegroup:
		*s = PostCommonServiceItemRequestCommonServiceItemProviderClassSaknoticegroup
	case PostCommonServiceItemRequestCommonServiceItemProviderClassSaknoticerouting:
		*s = PostCommonServiceItemRequestCommonServiceItemProviderClassSaknoticerouting
	default:
		*s = PostCommonServiceItemRequestCommonServiceItemProviderClass(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostCommonServiceItemRequestCommonServiceItemProviderClass) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemProviderClass) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PostCommonServiceItemRequestCommonServiceItemSettings as json.
func (s PostCommonServiceItemRequestCommonServiceItemSettings) Encode(e *jx.Encoder) {
	switch s.Type {
	case CommonServiceItemDestinationSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemDestinationSettings.Encode(e)
	case CommonServiceItemGroupSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemGroupSettings.Encode(e)
	case CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemRoutingSettings.Encode(e)
	}
}

func (s PostCommonServiceItemRequestCommonServiceItemSettings) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CommonServiceItemDestinationSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemDestinationSettings.encodeFields(e)
	case CommonServiceItemGroupSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemGroupSettings.encodeFields(e)
	case CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemRoutingSettings.encodeFields(e)
	}
}

// Decode decodes PostCommonServiceItemRequestCommonServiceItemSettings from json.
func (s *PostCommonServiceItemRequestCommonServiceItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PostCommonServiceItemRequestCommonServiceItemSettings to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "Destinations":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemGroupSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "MatchLabels":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "PriorityRank":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Number {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "SourceID":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "TargetGroupID":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "Type":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemDestinationSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "Value":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemDestinationSettingsPostCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CommonServiceItemDestinationSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		if err := s.CommonServiceItemDestinationSettings.Decode(d); err != nil {
			return err
		}
	case CommonServiceItemGroupSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		if err := s.CommonServiceItemGroupSettings.Decode(d); err != nil {
			return err
		}
	case CommonServiceItemRoutingSettingsPostCommonServiceItemRequestCommonServiceItemSettings:
		if err := s.CommonServiceItemRoutingSettings.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PostCommonServiceItemRequestCommonServiceItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PostCommonServiceItemRequestCommonServiceItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutCommonServiceItemRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutCommonServiceItemRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("CommonServiceItem")
		s.CommonServiceItem.Encode(e)
	}
}

var jsonFieldsNameOfPutCommonServiceItemRequest = [1]string{
	0: "CommonServiceItem",
}

// Decode decodes PutCommonServiceItemRequest from json.
func (s *PutCommonServiceItemRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutCommonServiceItemRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CommonServiceItem":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommonServiceItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutCommonServiceItemRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPutCommonServiceItemRequest) {
					name = jsonFieldsNameOfPutCommonServiceItemRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutCommonServiceItemRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutCommonServiceItemRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutCommonServiceItemRequestCommonServiceItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutCommonServiceItemRequestCommonServiceItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("Description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("Tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("Icon")
		s.Icon.Encode(e)
	}
	{
		if s.Settings.Set {
			e.FieldStart("Settings")
			s.Settings.Encode(e)
		}
	}
}

var jsonFieldsNameOfPutCommonServiceItemRequestCommonServiceItem = [5]string{
	0: "Name",
	1: "Description",
	2: "Tags",
	3: "Icon",
	4: "Settings",
}

// Decode decodes PutCommonServiceItemRequestCommonServiceItem from json.
func (s *PutCommonServiceItemRequestCommonServiceItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutCommonServiceItemRequestCommonServiceItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Description\"")
			}
		case "Tags":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Tags\"")
			}
		case "Icon":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Icon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Icon\"")
			}
		case "Settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Settings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutCommonServiceItemRequestCommonServiceItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPutCommonServiceItemRequestCommonServiceItem) {
					name = jsonFieldsNameOfPutCommonServiceItemRequestCommonServiceItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutCommonServiceItemRequestCommonServiceItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutCommonServiceItemRequestCommonServiceItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutCommonServiceItemRequestCommonServiceItemIcon) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutCommonServiceItemRequestCommonServiceItemIcon) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPutCommonServiceItemRequestCommonServiceItemIcon = [0]string{}

// Decode decodes PutCommonServiceItemRequestCommonServiceItemIcon from json.
func (s *PutCommonServiceItemRequestCommonServiceItemIcon) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutCommonServiceItemRequestCommonServiceItemIcon to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PutCommonServiceItemRequestCommonServiceItemIcon")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutCommonServiceItemRequestCommonServiceItemIcon) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutCommonServiceItemRequestCommonServiceItemIcon) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PutCommonServiceItemRequestCommonServiceItemSettings as json.
func (s PutCommonServiceItemRequestCommonServiceItemSettings) Encode(e *jx.Encoder) {
	switch s.Type {
	case CommonServiceItemDestinationSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemDestinationSettings.Encode(e)
	case CommonServiceItemGroupSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemGroupSettings.Encode(e)
	case CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemRoutingSettings.Encode(e)
	}
}

func (s PutCommonServiceItemRequestCommonServiceItemSettings) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case CommonServiceItemDestinationSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemDestinationSettings.encodeFields(e)
	case CommonServiceItemGroupSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemGroupSettings.encodeFields(e)
	case CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		s.CommonServiceItemRoutingSettings.encodeFields(e)
	}
}

// Decode decodes PutCommonServiceItemRequestCommonServiceItemSettings from json.
func (s *PutCommonServiceItemRequestCommonServiceItemSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutCommonServiceItemRequestCommonServiceItemSettings to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "Destinations":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemGroupSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "MatchLabels":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Array {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "PriorityRank":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.Number {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "SourceID":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "TargetGroupID":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "Type":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemDestinationSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "Value":
				// Type-based discrimination: check if field has expected JSON type
				if typ := d.Next(); typ != jx.String {
					// Field exists but has wrong type, not a match for this variant
					return d.Skip()
				}
				match := CommonServiceItemDestinationSettingsPutCommonServiceItemRequestCommonServiceItemSettings
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CommonServiceItemDestinationSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		if err := s.CommonServiceItemDestinationSettings.Decode(d); err != nil {
			return err
		}
	case CommonServiceItemGroupSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		if err := s.CommonServiceItemGroupSettings.Decode(d); err != nil {
			return err
		}
	case CommonServiceItemRoutingSettingsPutCommonServiceItemRequestCommonServiceItemSettings:
		if err := s.CommonServiceItemRoutingSettings.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PutCommonServiceItemRequestCommonServiceItemSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutCommonServiceItemRequestCommonServiceItemSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutCommonServiceItemRoutingReorderRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutCommonServiceItemRoutingReorderRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Orders")
		e.ArrStart()
		for _, elem := range s.Orders {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfPutCommonServiceItemRoutingReorderRequest = [1]string{
	0: "Orders",
}

// Decode decodes PutCommonServiceItemRoutingReorderRequest from json.
func (s *PutCommonServiceItemRoutingReorderRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutCommonServiceItemRoutingReorderRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Orders":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Orders = make([]PutCommonServiceItemRoutingReorderRequestOrdersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PutCommonServiceItemRoutingReorderRequestOrdersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Orders = append(s.Orders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Orders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutCommonServiceItemRoutingReorderRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPutCommonServiceItemRoutingReorderRequest) {
					name = jsonFieldsNameOfPutCommonServiceItemRoutingReorderRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutCommonServiceItemRoutingReorderRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutCommonServiceItemRoutingReorderRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PutCommonServiceItemRoutingReorderRequestOrdersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PutCommonServiceItemRoutingReorderRequestOrdersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("PriorityRank")
		e.Int(s.PriorityRank)
	}
	{
		e.FieldStart("RoutingID")
		e.Str(s.RoutingID)
	}
}

var jsonFieldsNameOfPutCommonServiceItemRoutingReorderRequestOrdersItem = [2]string{
	0: "PriorityRank",
	1: "RoutingID",
}

// Decode decodes PutCommonServiceItemRoutingReorderRequestOrdersItem from json.
func (s *PutCommonServiceItemRoutingReorderRequestOrdersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PutCommonServiceItemRoutingReorderRequestOrdersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "PriorityRank":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.PriorityRank = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PriorityRank\"")
			}
		case "RoutingID":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.RoutingID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RoutingID\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PutCommonServiceItemRoutingReorderRequestOrdersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfPutCommonServiceItemRoutingReorderRequestOrdersItem) {
					name = jsonFieldsNameOfPutCommonServiceItemRoutingReorderRequestOrdersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PutCommonServiceItemRoutingReorderRequestOrdersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PutCommonServiceItemRoutingReorderRequestOrdersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderRoutingAccepted) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderRoutingAccepted) encodeFields(e *jx.Encoder) {
	{
		if s.IsOk.Set {
			e.FieldStart("is_ok")
			s.IsOk.Encode(e)
		}
	}
}

var jsonFieldsNameOfReorderRoutingAccepted = [1]string{
	0: "is_ok",
}

// Decode decodes ReorderRoutingAccepted from json.
func (s *ReorderRoutingAccepted) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderRoutingAccepted to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_ok":
			if err := func() error {
				s.IsOk.Reset()
				if err := s.IsOk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderRoutingAccepted")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderRoutingAccepted) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderRoutingAccepted) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendNotificationMessageRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendNotificationMessageRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("Message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfSendNotificationMessageRequest = [1]string{
	0: "Message",
}

// Decode decodes SendNotificationMessageRequest from json.
func (s *SendNotificationMessageRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendNotificationMessageRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendNotificationMessageRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendNotificationMessageRequest) {
					name = jsonFieldsNameOfSendNotificationMessageRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendNotificationMessageRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendNotificationMessageRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SendNotificationMessageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SendNotificationMessageResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("is_ok")
		e.Bool(s.IsOk)
	}
}

var jsonFieldsNameOfSendNotificationMessageResponse = [1]string{
	0: "is_ok",
}

// Decode decodes SendNotificationMessageResponse from json.
func (s *SendNotificationMessageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SendNotificationMessageResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "is_ok":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsOk = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_ok\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SendNotificationMessageResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSendNotificationMessageResponse) {
					name = jsonFieldsNameOfSendNotificationMessageResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SendNotificationMessageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SendNotificationMessageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateCommonServiceItemOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateCommonServiceItemOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("CommonServiceItem")
		s.CommonServiceItem.Encode(e)
	}
}

var jsonFieldsNameOfUpdateCommonServiceItemOK = [1]string{
	0: "CommonServiceItem",
}

// Decode decodes UpdateCommonServiceItemOK from json.
func (s *UpdateCommonServiceItemOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCommonServiceItemOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "CommonServiceItem":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CommonServiceItem.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CommonServiceItem\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateCommonServiceItemOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateCommonServiceItemOK) {
					name = jsonFieldsNameOfUpdateCommonServiceItemOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCommonServiceItemOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCommonServiceItemOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
